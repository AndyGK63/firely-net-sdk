<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ include file="TemplateFileManagerV2.1.ttinclude" #>
<#@ include file="Template-Children.ttinclude" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#
	var manager = TemplateFileManager.Create(this);

	var versions = new[] { "DSTU2", "STU3" };
	var rootDirectory = Path.GetDirectoryName(this.Host.TemplateFile)
	var loadedVersions = LoadedVersion.LoadAll(versions, rootDirectory);
	var valueSetsByEnumNameByVersion = ValueSet.LoadAll(loadedVersions);
	var resourcesByNameByVersion = ResourceDetails.LoadAll(loadedVersions, valueSetsByEnumNameByVersion);
    foreach (var pair in resourcesByNameByVersion)
    {
		var version = pair.Key;
		var resourcesByName = pair.Value;
		var destinationDirectory = string.IsNullOrEmpty(version) ? "." : version;
		var fhirVersion = loadedVersions.SingleOrDefault( lv => lv.Version == version )?.FhirVersion;
		if (fhirVersion == null)
		{
			fhirVersion = string.Join( ", v", loadedVersions.Select( lv => lv.FhirVersion ));
		}
		var dotVersion = string.IsNullOrEmpty(version) ? string.Empty : "." + version;
        foreach (var resource in resourcesByName.Values)
			manager.StartNewFile(destinationDirectory + "\\" + resource.Name + ".cs");
#>
//
// Model Generated on <#= DateTime.Now.ToString("R") #> for FHIR v<#= fhirVersion #>
//
using System;
using System.Collections.Generic;
using Hl7.Fhir.Introspection;
using Hl7.Fhir.Validation;
using System.Linq;
using System.Runtime.Serialization;
using Hl7.Fhir.Utility;

/*
  Copyright (c) 2011+, HL7, Inc.
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  

*/
#pragma warning disable 1591 // suppress XML summary warnings

namespace Hl7.Fhir.Model<#= dotVersion #>
{
<# if (!string.IsNullOrEmpty(resource.Description)) { #>    /// <summary>
    /// <#= StringUtils.ConvertComment(resource.Description) #>
    /// </summary>
<# }
if(!resource.AbstractType) {
 #>    [FhirType("<#= resource.Name #>"<#= resource.BaseType != "Hl7.Fhir.Model.Element" ? ", IsResource=true" : "" #>)]
<# }
#>    [DataContract]
    public<#= resource.AbstractType ? " abstract" : "" #> partial class <#= resource.Name #> : <#= resource.BaseType #>, System.ComponentModel.INotifyPropertyChanged
    {
<# if (resource.BaseType != "Hl7.Fhir.Model.Element") { #>        [NotMapped]
        public override ResourceType ResourceType { get { return ResourceType.<#= resource.Name #>; } }
<# } #>        [NotMapped]
        public override string TypeName { get { return "<#= resource.Name #>"; } }
        
<#
	// This is the generation for the Components of the class
	foreach (var component in resource.Components)
    {
#>
        [FhirType("<#= component.Name #>")]
        [DataContract]
        public partial class <#= component.Name #> : Hl7.Fhir.Model.BackboneElement, System.ComponentModel.INotifyPropertyChanged
        {
            [NotMapped]
            public override string TypeName { get { return "<#= component.Name #>"; } }
            
<#
	int nComponentPropNum = 30;
	foreach (var pd in component.Properties)
    {
		nComponentPropNum += 10;
#>
            /// <summary>
            /// <#= StringUtils.ConvertComment(pd.Summary) #>
            /// </summary>
            [FhirElement("<#= pd.FhirName #>", <# Write(pd.IsSummaryVersions.Count > 0 ? "InSummary=true, " : ""); #>Order=<#= nComponentPropNum #><#= pd.PropType == "Hl7.Fhir.Model.Element" ? ", Choice=ChoiceType.DatatypeChoice" : pd.PropType == "Hl7.Fhir.Model.Resource" ? ", Choice=ChoiceType.ResourceChoice" : "" #>)]
<# if (pd.ReferenceTargets.Count > 0) {#>
            [CLSCompliant(false)]
			[References(<#= string.Join(",", pd.ReferenceTargets.Select(rt => "\"" + rt + "\"")) #>)]
<# }
#>
<# if (pd.AllowedTypes.Count > 0) {#>
            [CLSCompliant(false)]
			[AllowedTypes(<#= string.Join(",", pd.AllowedTypes.Select(at => "typeof(" + at + ")")) #>)]
<# }
#>
<# if (pd.CardMax == "*" || pd.CardMin != "0") {#>
            [Cardinality(Min=<#= pd.CardMin #>,Max=<#= pd.CardMax.Replace("*", "-1") #>)]
<# }
#>
            [DataMember]
            public <#= pd.PropTypeWithCard().Replace("Hl7.Fhir.Model.Code<", "Code<") #> <#= pd.Name #>
            {
<#if (pd.IsMultiCard()){#>                get { if(_<#= pd.Name #>==null) _<#= pd.Name #> = new <#= pd.PropTypeWithCard() #>(); return _<#= pd.Name #>; }
<#}else{#>                get { return _<#= pd.Name #>; }
<#}#>                set { _<#= pd.Name #> = value; OnPropertyChanged("<#= pd.Name #>"); }
            }
            
            private <#= pd.PropTypeWithCard().Replace("Hl7.Fhir.Model.Code<", "Code<") #> _<#= pd.Name #>;
            
<#
			if (!string.IsNullOrEmpty(pd.NativeName))
			{
#>
            /// <summary>
            /// <#= StringUtils.ConvertComment(pd.Summary) #>
            /// </summary>
            /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
<# if (false && pd.CardMax != "1") {#>        [Cardinality(Min=<#= pd.CardMin #>,Max=<#= pd.CardMax.Replace("*", "-1") #>)] 
<# }
#>
            [NotMapped]
            [IgnoreDataMemberAttribute]
            public <#= pd.IsMultiCard() ? "IEnumerable<" + pd.NativeType + ">" : pd.NativeType #> <#= pd.NativeName #>
            {
<#if (pd.IsMultiCard()){#>                get { return <#= pd.Name #> != null ? <#= pd.Name #>.Select(elem => elem.Value) : null; }
<#}else{#>                get { return <#= pd.Name #> != null ? <#= pd.Name #>.Value : null; }
<#}#>
                set
                {
                    if (<#= !pd.IsMultiCard() && pd.NativeType.EndsWith("?") ? "!value.HasValue" : "value == null" #>)
                        <#= pd.Name #> = null; 
                    else
                        <#= pd.Name #> = new <#= pd.IsMultiCard() ? "List<" + pd.PropType + ">(value.Select(elem=>new "+pd.PropType+"(elem)))" : pd.PropType.Replace("Hl7.Fhir.Model.Code<", "Code<") + "(value)" #>;
                    OnPropertyChanged("<#= pd.NativeName #>");
                }
            }
            
<#
			}
	    }
#>
            public override IDeepCopyable CopyTo(IDeepCopyable other)
            {
                var dest = other as <#= component.Name #>;
                
                if (dest != null)
                {
                    base.CopyTo(dest);
<#
	foreach (var pd in component.Properties)
    {
		if (pd.CardMax == "*")
			WriteLine("                    if({0} != null) dest.{0} = new List<{1}>({0}.DeepCopy());", pd.Name, pd.PropType.Replace("Hl7.Fhir.Model.Code<", "Code<"), pd.CardMax);
		else
			WriteLine("                    if({0} != null) dest.{0} = ({1}){0}.DeepCopy();", pd.Name, pd.PropType.Replace("Hl7.Fhir.Model.Code<", "Code<"), pd.CardMax);
    }
#>
                    return dest;
                }
                else
                	throw new ArgumentException("Can only copy to an object of the same type", "other");
            }
            
<# if (!resource.AbstractType){
#>            public override IDeepCopyable DeepCopy()
            {
                return CopyTo(new <#= component.Name #>());
            }
            
<# } #>            public override bool Matches(IDeepComparable other)
            {
                var otherT = other as <#= component.Name #>;
                if(otherT == null) return false;
                
                if(!base.Matches(otherT)) return false;
<#
	foreach (var pd in component.Properties)
    {
		if (pd.CardMax == "*")
			WriteLine("                if( !DeepComparable.Matches({0}, otherT.{0})) return false;", pd.Name, pd.PropType, pd.CardMax);
		else
			WriteLine("                if( !DeepComparable.Matches({0}, otherT.{0})) return false;", pd.Name, pd.PropType, pd.CardMax);
    }
#>
                
                return true;
            }
            
            public override bool IsExactly(IDeepComparable other)
            {
                var otherT = other as <#= componentName #>;
                if(otherT == null) return false;
                
                if(!base.IsExactly(otherT)) return false;
<#
	foreach (var pd in component.Properties)
    {
		WriteLine("                if( !DeepComparable.IsExactly({0}, otherT.{0})) return false;", pd.Name, pd.PropType, pd.CardMax);
    }
#>
                
                return true;
            }

<#
		    // [WMR 20160818] START - implement generic properties collection
#>

            [NotMapped]
            public override IEnumerable<Base> Children
            {
                get
                {
                    foreach (var item in base.Children) yield return item;
<#
					YieldComponent(loadedVersion.Types, component.Name, "BackboneElement", component.Properties, loadedVersion.NSR, enums, "                    ", withName:false);
#>
                }
            }

            [NotMapped]
            internal override IEnumerable<ElementValue> NamedChildren
            {
                get
                {
                    foreach (var item in base.NamedChildren) yield return item;
<#
					YieldComponent(loadedVersion.Types, component.Name, "BackboneElement", component.Properties, loadedVersion.NSR, enums, "                    ", withName:true);
#>
                }
            }

<#
		    // [WMR 20160818] END - implement generic properties collection
#>
            
        }
        
        
<#
    }

	// Read each of the properties out
	int nPropNum = 80;
	if (resource.BaseType == "Hl7.Fhir.Model.Resource")
		nPropNum = 40;
	if (resource.BaseType == "Hl7.Fhir.Model.Element")
		nPropNum = 20;

	foreach (var pd in resource.Properties)
    {
		nPropNum += 10;
#>
        /// <summary>
        /// <#= StringUtils.ConvertComment(pd.Summary) #>
        /// </summary>
        [FhirElement("<#= pd.FhirName #>", <# Write(pd.IsSummaryVersions.Count > 0 ? "InSummary=true, " : ""); #>Order=<#= nPropNum #><#= pd.PropType == "Hl7.Fhir.Model.Element" ? ", Choice=ChoiceType.DatatypeChoice" : pd.PropType == "Hl7.Fhir.Model.Resource" ? ", Choice=ChoiceType.ResourceChoice" : "" #>)]
<# if (pd.ReferenceTargets.Count > 0) {#>
        [CLSCompliant(false)]
		[References(<#= string.Join(",",pd.ReferenceTargets.Select(rt => "\"" + rt + "\"")) #>)]
<# }
#>
<# if (pd.AllowedTypes.Count > 0) {#>
        [CLSCompliant(false)]
		[AllowedTypes(<#= pd.AllowedTypes #>)]
<# }
#>
<# if (pd.CardMax != "1" || pd.CardMin != "0") {#>
        [Cardinality(Min=<#= pd.CardMin #>,Max=<#= pd.CardMax.Replace("*", "-1") #>)]
<# }
#>
        [DataMember]
        public <#= pd.PropTypeWithCard().Replace("Hl7.Fhir.Model.Code<", "Code<") #> <#= pd.Name #>
        {
<#if (pd.IsMultiCard()){#>            get { if(_<#= pd.Name #>==null) _<#= pd.Name #> = new <#= pd.PropTypeWithCard() #>(); return _<#= pd.Name #>; }
<#}else{#>            get { return _<#= pd.Name #>; }
<#}#>            set { _<#= pd.Name #> = value; OnPropertyChanged("<#= pd.Name #>"); }
        }
        
        private <#= pd.PropTypeWithCard().Replace("Hl7.Fhir.Model.Code<", "Code<") #> _<#= pd.Name #>;
        
<#
		if (!string.IsNullOrEmpty(pd.NativeName))
        {
#>
        /// <summary>
        /// <#= pd.Summary.Replace("&", "&amp;").Replace("\r\n", "\n").Replace("\r", "\n").Replace("\n\n", "\n").Replace("\n", "\r\n        /// ") #>
        /// </summary>
        /// <remarks>This uses the native .NET datatype, rather than the FHIR equivalent</remarks>
<# if (false && pd.CardMax != "1") {#>        [Cardinality(Min=<#= pd.CardMin #>,Max=<#= pd.CardMax.Replace("*", "-1") #>)] 
<# }
#>
        [NotMapped]
        [IgnoreDataMemberAttribute]
        public <#= pd.IsMultiCard() ? "IEnumerable<" + pd.NativeType + ">" : pd.NativeType #> <#= pd.NativeName #>
        {
<#if (pd.IsMultiCard()){#>            get { return <#= pd.Name #> != null ? <#= pd.Name #>.Select(elem => elem.Value) : null; }
<#}else{#>            get { return <#= pd.Name #> != null ? <#= pd.Name #>.Value : null; }
<#}#>
            set
            {
                if (<#= !pd.IsMultiCard() && pd.NativeType.EndsWith("?") ? "!value.HasValue" : "value == null" #>)
                  <#= pd.Name #> = null; 
                else
                  <#= pd.Name #> = new <#= pd.IsMultiCard() ? "List<" + pd.PropType + ">(value.Select(elem=>new "+pd.PropType+"(elem)))" : pd.PropType.Replace("Hl7.Fhir.Model.Code<", "Code<") + "(value)" #>;
                OnPropertyChanged("<#= pd.NativeName #>");
            }
        }
        
<#
        }
    }

#><# if (resourceName != "DomainResource2") { #>

<#
            foreach (XmlElement node in e.SelectNodes("fhir:differential/fhir:element/fhir:constraint", loadedVersion.NSR))
            {
                string expression = node.SelectSingleNode("fhir:extension[@url='http://hl7.org/fhir/StructureDefinition/structuredefinition-expression']/fhir:valueString/@value|fhir:expression/@value", loadedVersion.NSR).Value;
                string parentPath = node.ParentNode.SelectSingleNode("fhir:path/@value", loadedVersion.NSR).Value;
                if (parentPath.Contains("."))
                {
                    // This expression applied to a backbone element, so need to give it scope
                    expression = parentPath.Replace("[x]", "").Replace(resourceName + ".", "") + ".all(" + expression + ")";
                }
                string key = node.SelectSingleNode("fhir:key/@value", loadedVersion.NSR).Value;
                string severity = node.SelectSingleNode("fhir:severity/@value", loadedVersion.NSR).Value;
                string human = node.SelectSingleNode("fhir:human/@value", loadedVersion.NSR).Value;
                string xpath = node.SelectSingleNode("fhir:xpath/@value", loadedVersion.NSR).Value;
#>        public static ElementDefinition.ConstraintComponent <#= resourceName + "_" + key.Replace("-", "_").ToUpper() #> = new ElementDefinition.ConstraintComponent()
        {
            Extension = new List<Model.Extension>() { new Model.Extension("http://hl7.org/fhir/StructureDefinition/structuredefinition-expression", new FhirString("<#= expression.Replace("\"", "\\\"") #>"))},
            Key = "<#= key #>",
            Severity = <#= severity == "Error" ? "ElementDefinition.ConstraintSeverity.Error" : "ElementDefinition.ConstraintSeverity.Warning" #>,
            Human = "<#= human.Replace("\"", "\\\"") #>",
            Xpath = "<#= xpath.Replace("\"", "\\\"") #>"
        };

<#            }
#>
<#}#>
        public override void AddDefaultConstraints()
        {
            base.AddDefaultConstraints();

<#
            foreach (XmlElement node in e.SelectNodes("fhir:differential/fhir:element/fhir:constraint", loadedVersion.NSR))
            {
                string expression = node.SelectSingleNode("fhir:extension[@url='http://hl7.org/fhir/StructureDefinition/structuredefinition-expression']/fhir:valueString/@value|fhir:expression/@value", loadedVersion.NSR).Value;
                string parentPath = node.ParentNode.SelectSingleNode("fhir:path/@value", loadedVersion.NSR).Value;
                if (parentPath.Contains("."))
                {
                    // This expression applied to a backbone element, so need to give it scope
                    expression = parentPath.Replace(resourceName + ".", "") + ".all(" + expression + ")";
                }
                string key = node.SelectSingleNode("fhir:key/@value", loadedVersion.NSR).Value;
                string severity = node.SelectSingleNode("fhir:severity/@value", loadedVersion.NSR).Value;
                string human = node.SelectSingleNode("fhir:human/@value", loadedVersion.NSR).Value;
                string xpath = node.SelectSingleNode("fhir:xpath/@value", loadedVersion.NSR).Value;
#>            InvariantConstraints.Add(<#= resourceName + "_" + key.Replace("-", "_").ToUpper() #>);
<#            }
#>        }

        public override IDeepCopyable CopyTo(IDeepCopyable other)
        {
            var dest = other as <#= resourceName #>;
            
            if (dest != null)
            {
                base.CopyTo(dest);
<#
	foreach (PropertyDetails pd in props)
    {
		if (pd.CardMax == "*")
			WriteLine("                if({0} != null) dest.{0} = new List<{1}>({0}.DeepCopy());", pd.Name, pd.PropType.Replace("Hl7.Fhir.Model.Code<", "Code<"), pd.CardMax);
		else
			WriteLine("                if({0} != null) dest.{0} = ({1}){0}.DeepCopy();", pd.Name, pd.PropType.Replace("Hl7.Fhir.Model.Code<", "Code<"), pd.CardMax);
    }
#>
                return dest;
            }
            else
            	throw new ArgumentException("Can only copy to an object of the same type", "other");
        }
        
<# if (!abstractType){
#>        public override IDeepCopyable DeepCopy()
        {
            return CopyTo(new <#= resourceName #>());
        }
        
<# } 
#>        public override bool Matches(IDeepComparable other)
        {
            var otherT = other as <#= resourceName #>;
            if(otherT == null) return false;
            
            if(!base.Matches(otherT)) return false;
<#
	foreach (PropertyDetails pd in props)
    {
		if (pd.CardMax == "*")
			WriteLine("            if( !DeepComparable.Matches({0}, otherT.{0})) return false;", pd.Name); // , pd.PropType, pd.CardMax);
		else
			WriteLine("            if( !DeepComparable.Matches({0}, otherT.{0})) return false;", pd.Name); // , pd.PropType, pd.CardMax);
    }
#>
            
            return true;
        }
        
        public override bool IsExactly(IDeepComparable other)
        {
            var otherT = other as <#= resourceName #>;
            if(otherT == null) return false;
            
            if(!base.IsExactly(otherT)) return false;
<#
	foreach (PropertyDetails pd in props)
    {
		WriteLine("            if( !DeepComparable.IsExactly({0}, otherT.{0})) return false;", pd.Name); // , pd.PropType, pd.CardMax);
    }
#>
            
            return true;
        }

<#
		// [WMR 20160818] START - implement generic properties collection
#>
        [NotMapped]
        public override IEnumerable<Base> Children
        {
            get
            {
                foreach (var item in base.Children) yield return item;
<#
				YieldChildren(loadedVersion.Resources, e as System.Xml.XmlElement, loadedVersion.NSR, enums, "				", withName:false);
#>
            }
        }

        [NotMapped]
        internal override IEnumerable<ElementValue> NamedChildren
        {
            get
            {
                foreach (var item in base.NamedChildren) yield return item;
<#
                YieldChildren(loadedVersion.Resources, e as System.Xml.XmlElement, loadedVersion.NSR, enums, "                ", withName:true);
#>
            }
        }

<#
		// [WMR 20160818] END - implement generic properties collection
#>
    }
    
}
<#
        }
	}
	manager.Process();
#>
<#+
public static class StringUtils
{
    // convert the name into a valid Enum Value
    public static string ConvertEnumValue(string name)
    {
        if (name.StartsWith("_"))
            name = name.Substring(1);
        if (name == "=")
            return "Equal";
        if (name == "<")
            return "LessThan";
        if (name == "<=")
            return "LessOrEqual";
        if (name == ">=")
            return "GreaterOrEqual";
        if (name == ">")
            return "GreaterThan";
        string[] bits = name.Split(new char[] { ' ', '-' });
        string result = null;
        foreach (var bit in bits)
        {
            result += bit.Substring(0, 1).ToUpper();
            result += bit.Substring(1);
        }
        int IsIntegerValue;
        if (int.TryParse(result, out IsIntegerValue))
            result = "N" + result;
        return result;
    }

    public static string ConvertComment(string comment)
    {
        return comment.Replace("\r", "\n").Replace("\n\n", "\n").Replace("<", "&lt;").Replace(">", "&gt;").Replace("\n", "<br/>\r\n        /// ");
    }
}

public class LoadedVersion
{
    public string Version;
    public XmlDocument Resources;
    public XmlNamespaceManager NSR;
    public XmlDocument Expansions;
    public XmlNamespaceManager NSE;
    public XmlDocument Types;
    public XmlNamespaceManager NST;
    public string FhirVersion;

    // rootDirectory = Path.GetDirectoryName(this.Host.TemplateFile)
    public static List<LoadedVersion> LoadAll(IEnumerable<string> versions, string rootDirectory)
    {
        var result = new List<LoadedVersion>();
        foreach (var version in versions)
        {
            result.Add(Load(version, rootDirectory));
        }
        return result;
    }

    private static LoadedVersion Load(string version, string rootDirectory)
    {
        var result = new LoadedVersion();

        result.Version = version;

        result.Resources = new XmlDocument();
        result.Resources.Load(rootDirectory + "\\..\\Source-" + version + "\\profiles-resources.xml");
        result.NSR = new XmlNamespaceManager(result.Resources.NameTable);
        result.NSR.AddNamespace("fhir", "http://hl7.org/fhir");

        result.Expansions = new XmlDocument();
        result.Expansions.Load(rootDirectory + "\\..\\Source-" + version + "\\expansions.xml");
        result.NSE = new XmlNamespaceManager(result.Expansions.NameTable);
        result.NSE.AddNamespace("fhir", "http://hl7.org/fhir");

        result.Types = new XmlDocument();
        result.Types.Load(rootDirectory + "\\..\\Source-" + version + "\\profiles-types.xml");
        result.NST = new XmlNamespaceManager(result.Types.NameTable);
        result.NST.AddNamespace("fhir", "http://hl7.org/fhir");

        result.FhirVersion = result.Resources.SelectSingleNode("//fhir:fhirVersion/@value", result.NSE).Value;

        return result;
    }
}

public class ValueSet
{
    public string EnumName;
    public string Url;
    public string Description;
    public List<ValueSetValue> Values;

    public bool IsSame(ValueSet other)
    {
        return other != null &&
            EnumName == other.EnumName &&
            GetSortedCodesString() == other.GetSortedCodesString();
    }

    public string GetSortedCodesString()
    {
        if (Values == null)
        {
            return string.Empty;
        }
        return string.Join(", ", Values.Select(v => v.Code).OrderBy(c => c));
    }

    public static Dictionary<string, Dictionary<string, ValueSet>> LoadAll(IEnumerable<LoadedVersion> loadedVersions)
    {
        var valueSetsByEnumNameByVersion = new Dictionary<string, Dictionary<string, ValueSet>>();
        foreach (var loadedVersion in loadedVersions)
        {
            var valueSetsByEnumName = new Dictionary<string, ValueSet>();
            valueSetsByEnumNameByVersion.Add(loadedVersion.Version, valueSetsByEnumName);
            var nodesResources = loadedVersion.Resources.DocumentElement.SelectNodes(
                "/fhir:Bundle/fhir:entry/fhir:resource/fhir:StructureDefinition[fhir:differential/fhir:element[fhir:type/fhir:code/@value = 'code' and fhir:binding/fhir:strength/@value='required']]", loadedVersion.NSR);
            var nodesTypesRoot = loadedVersion.Types.DocumentElement.SelectNodes(
                "/fhir:Bundle/fhir:entry/fhir:resource/fhir:StructureDefinition[fhir:differential/fhir:element[fhir:type/fhir:code/@value = 'code' and fhir:binding/fhir:strength/@value='required']]", loadedVersion.NST);
            var allElements = nodesResources.OfType<XmlElement>().Concat(nodesTypesRoot.OfType<XmlElement>());
            foreach (var element in allElements)
            {
                foreach (var eProp in element.SelectNodes("fhir:differential/fhir:element[fhir:type/fhir:code/@value = 'code' and fhir:binding]", loadedVersion.NSR).OfType<XmlElement>())
                {
                    string valuesetUrl = null;
                    var n3 = eProp.SelectSingleNode("fhir:binding/fhir:valueSetUri/@value", loadedVersion.NSR);
                    if (n3 != null)
                    {
                        valuesetUrl = n3.Value;
                    }
                    var n4 = eProp.SelectSingleNode("fhir:binding/fhir:valueSetReference/fhir:reference/@value", loadedVersion.NSR);
                    if (n4 != null)
                    {
                        valuesetUrl = n4.Value;
                    }
                    var valuesetElement = loadedVersion.Expansions.SelectSingleNode("/fhir:Bundle/fhir:entry/fhir:resource/fhir:ValueSet[fhir:url/@value = '" + valuesetUrl + "']", loadedVersion.NSE) as XmlElement;
                    if (valuesetElement != null)
                    {
                        var enumName = valuesetElement.SelectSingleNode("fhir:name/@value", loadedVersion.NSE).InnerText;
                        // reformat the name so that it is a valid .NET enumeration name
                        enumName = enumName.Replace(" ", "").Replace("-", "_");
                        if (!valueSetsByEnumName.ContainsKey(enumName))
                        {
                            var valueSet = new ValueSet
                            {
                                EnumName = enumName,
                                Url = valuesetUrl,
                                Description = valuesetElement.SelectSingleNode("fhir:description/@value", loadedVersion.NSE).InnerText,
                                Values = new List<ValueSetValue>()
                            };
                            valueSetsByEnumName.Add(enumName, valueSet);
                            var codedValues = new HashSet<string>();
                            foreach (var eval in valuesetElement.SelectNodes("fhir:expansion/fhir:contains", loadedVersion.NSE).OfType<XmlElement>())
                            {
                                var code = eval.SelectSingleNode("fhir:code/@value", loadedVersion.NSE).Value;
                                var enumValue = StringUtils.ConvertEnumValue(code);
                                if (!codedValues.Contains(enumValue))
                                {
                                    codedValues.Add(enumValue);
                                    var valueSetValue = new ValueSetValue { Code = code };
                                    var system = eval.SelectSingleNode("fhir:system/@value", loadedVersion.NSE).Value;
                                    valueSetValue.System = system;
                                    valueSetValue.Display = eval.SelectSingleNode("fhir:display/@value", loadedVersion.NSE).Value;
                                    string definition = null;
                                    var definitionNode = valuesetElement.SelectSingleNode("fhir:codeSystem[fhir:system/@value = '" + system + "']/fhir:concept[fhir:code/@value = '" + code + "']/fhir:definition/@value", loadedVersion.NSE);
                                    if (definitionNode != null)
                                    {
                                        definition = definitionNode.Value;
                                    }
                                    else
                                    {
                                        definitionNode = valuesetElement.SelectSingleNode("fhir:codeSystem[fhir:system/@value = '" + system + "']/fhir:concept/fhir:concept[fhir:code/@value = '" + code + "']/fhir:definition/@value", loadedVersion.NSE);
                                        if (definitionNode != null)
                                        {
                                            definition = definitionNode.Value;
                                        }
                                    }
                                    if (string.IsNullOrEmpty(definition))
                                    {
                                        definition = "MISSING DESCRIPTION";
                                    }
                                    valueSetValue.Definition = definition;
                                    valueSet.Values.Add(valueSetValue);
                                }
                            }
                        }
                    }
                }
            }
        }
        ExtractShared(valueSetsByEnumNameByVersion);
        return valueSetsByEnumNameByVersion;
    }

    private static void ExtractShared(Dictionary<string, Dictionary<string, ValueSet>> valueSetsByEnumNameByVersion)
    {
        var sharedValueSetsByEnumName = new Dictionary<string, ValueSet>();
        var allEnumNames = valueSetsByEnumNameByVersion.Values
            .SelectMany(valueSetsByEnumName => valueSetsByEnumName.Keys)
            .Distinct()
            .ToList();
        foreach (var enumName in allEnumNames)
        {
            var valueSetsWithSameEnumName = valueSetsByEnumNameByVersion.Values
                .Where(valueSetsByEnumName => valueSetsByEnumName.ContainsKey(enumName))
                .Select(valueSetsByEnumName => valueSetsByEnumName[enumName])
                .ToList();
            if (valueSetsWithSameEnumName.Count > 1 && valueSetsWithSameEnumName.Skip(1).All(vs => valueSetsWithSameEnumName[0].IsSame(vs)))
            {
                sharedValueSetsByEnumName.Add(enumName, valueSetsWithSameEnumName[0]);
                foreach (var valueSetsByEnumName in valueSetsByEnumNameByVersion.Values)
                {
                    valueSetsByEnumName.Remove(enumName);
                }
            }
        }
        valueSetsByEnumNameByVersion.Add(string.Empty, sharedValueSetsByEnumName);
    }
}

public class ValueSetValue
{
    public string System;
    public string Code;
    public string Display;
    public string Definition;
}

public class ResourceDetails
{
    public string Name;
    public string Description;
    public string RawName;
    public bool AbstractType;
    public string BaseType;
    public bool IsPrimitive;
    public string PrimitiveTypeName;
    public string Pattern;
    public List<PropertyDetails> Properties;
    public List<ComponentDetails> Components;

    public void Dump(StreamWriter writer)
    {
        writer.WriteLine(
            "{0}: {1}{2}{3}{4}{5}",
            Name,
            BaseType,
            AbstractType ? " abstract" : string.Empty,
            IsPrimitive ? " primitive" : string.Empty,
            string.IsNullOrEmpty(PrimitiveTypeName) ? string.Empty : " primitiveType: " + PrimitiveTypeName,
            string.IsNullOrEmpty(Pattern) ? string.Empty : " pattern: " + Pattern
        );
        foreach (var prop in Properties)
        {
            writer.WriteLine(
                "    {0}: {1}{2} {3} {4}{5}{6}",
                prop.Name,
                prop.BackboneComponentType ?? prop.PropType,
                prop.IsSummaryVersions.Count > 0 ? " summary(" + string.Join(",", prop.IsSummaryVersions) + ")" : string.Empty,
                prop.CardMin,
                prop.CardMax,
                prop.ReferenceTargets.Count == 0 ? string.Empty : " targets: " + string.Join(",", prop.ReferenceTargets),
                prop.AllowedTypes.Count == 0 ? string.Empty : " allowed types: " + string.Join(",", prop.AllowedTypes)
             );
        }
        foreach (var comp in Components)
        {
            writer.WriteLine("    ---- Component {0}", comp.Name);
            foreach (var comprop in comp.Properties)
            {
                writer.WriteLine("        {0}: {1}", comprop.Name, comprop.BackboneComponentType ?? comprop.PropType);
            }
        }
    }

    public bool IsSame(ResourceDetails other)
    {
        return other != null &&
            Name == other.Name &&
            AbstractType == other.AbstractType &&
            BaseType == other.BaseType &&
            IsPrimitive == other.IsPrimitive &&
            PrimitiveTypeName == other.PrimitiveTypeName &&
            Pattern == other.Pattern &&
            Properties.Count == other.Properties.Count &&
            Properties.OrderBy(p => p.Name).Zip(other.Properties.OrderBy(p => p.Name), (p1, p2) => p1.IsSame(p2)).All(same => same) &&
            Components.Count == other.Components.Count &&
            Components.OrderBy(c => c.Name).Zip(other.Components.OrderBy(c => c.Name), (c1, c2) => c1.IsSame(c2)).All(same => same);
    }

    public static ResourceDetails MergeSame(IEnumerable<KeyValuePair<string, ResourceDetails>> versionAndResources)
    {
        var firstResource = versionAndResources.First().Value;
        return new ResourceDetails
        {
            Name = firstResource.Name,
            Description = firstResource.Description,
            RawName = firstResource.RawName,
            AbstractType = firstResource.AbstractType,
            BaseType = firstResource.BaseType,
            IsPrimitive = firstResource.IsPrimitive,
            PrimitiveTypeName = firstResource.PrimitiveTypeName,
            Pattern = firstResource.Pattern,
            Properties = firstResource.Properties
                .Select( 
                    prop => PropertyDetails.MergeSame( 
                        versionAndResources.Select( pair => new KeyValuePair<string, PropertyDetails>(pair.Key, pair.Value.Properties.Single(p => p.Name == prop.Name)))
                    )
                )
                .ToList(),
            Components = firstResource.Components
                .Select(
                    comp => ComponentDetails.MergeSame(
                        versionAndResources.Select(pair => new KeyValuePair<string, ComponentDetails>(pair.Key, pair.Value.Components.Single(c => c.Name == comp.Name)))
                    )
                )
                .ToList(),
        };
    }

    public IEnumerable<string> GetReferencedFhirTypes()
    {
        const string prefix = "Hl7.Fhir.Model.";
        return GetAllProperties()
            .Where(p => p.PropType.StartsWith(prefix))
            .Select(p => p.PropType.Substring(prefix.Length));
    }

    public void FixReferencedFhirTypes(string version, Dictionary<string,ResourceDetails> resourcesByName)
    {
        foreach (var prop in GetAllProperties())
        {
            prop.FixReferencedFhirTypes(version, resourcesByName);
        }
    }

    private IEnumerable<PropertyDetails> GetAllProperties()
    {
        return Properties.Concat(Components.SelectMany(c => c.Properties));
    }

    public static List<ResourceDetails> Load(LoadedVersion loadedVersion, Dictionary<string, string> enumTypesByValueSetUrl)
    {
        var result = new List<ResourceDetails>();
        var sdNodes = loadedVersion.Resources.DocumentElement.SelectNodes("/fhir:Bundle/fhir:entry/fhir:resource/fhir:StructureDefinition", loadedVersion.NSR);
        foreach (var e in sdNodes.OfType<XmlElement>())
        {
            var resourceName = e.SelectSingleNode("fhir:name/@value", loadedVersion.NSR).Value;

            var resourceBaseType = "Hl7.Fhir.Model.DomainResource";
            var resourceBaseTypeNode = GetBaseTypeNode(e, loadedVersion.NSR);
            if (resourceBaseTypeNode != null)
            {
                resourceBaseType = resourceBaseTypeNode.Value;
                if (resourceBaseType == "http://hl7.org/fhir/StructureDefinition/Resource")
                    resourceBaseType = "Hl7.Fhir.Model.Resource";
                else if (resourceBaseType == "http://hl7.org/fhir/StructureDefinition/Element")
                    resourceBaseType = "Hl7.Fhir.Model.Element";
                else if (resourceBaseType == "http://hl7.org/fhir/StructureDefinition/Quantity")
                    resourceBaseType = "Hl7.Fhir.Model.Quantity";
                else
                    resourceBaseType = "Hl7.Fhir.Model.DomainResource";
            }

            if (resourceName != "Resource" && resourceBaseType != "Hl7.Fhir.Model.Quantity")
            {
                var resource = new ResourceDetails { Name = resourceName, BaseType = resourceBaseType };
                result.Add(resource);

                var resourceDescriptionNode = e.SelectSingleNode("fhir:differential/fhir:element[fhir:path/@value='" + resourceName + "']/fhir:short/@value", loadedVersion.NSR);
                resource.Description = resourceDescriptionNode == null ? string.Empty : resourceDescriptionNode.Value;

                resource.AbstractType = (e.SelectSingleNode("fhir:abstract[@value='true']", loadedVersion.NSR) != null);

                resource.Properties = GetProperties( resourceName, e, loadedVersion.NSR, enumTypesByValueSetUrl );

                resource.Components = new List<ComponentDetails>();
                foreach (var e2 in e.SelectNodes("fhir:differential/fhir:element[fhir:type/fhir:code/@value = 'BackboneElement']", loadedVersion.NSR).OfType<XmlElement>())
                {
                    var componentElement = e2.SelectSingleNode("fhir:path/@value", loadedVersion.NSR) as XmlAttribute;
                    var v = componentElement.Value;
                    if (v.Contains("."))
                    {
                        var index = v.LastIndexOf(".");
                        v = v.Substring(index + 1, 1).ToUpper() + v.Substring(index + 2);
                    }
                    var componentName = v + "Component";
                    var componentNameElement = (XmlAttribute)e2.SelectSingleNode("fhir:extension[@url = 'http://hl7.org/fhir/StructureDefinition/structuredefinition-explicit-type-name']/fhir:valueString/@value", loadedVersion.NSR);
                    if (componentNameElement != null)
                    {
                        componentName = componentNameElement.Value + "Component";
                    }

                    var component = new ComponentDetails
                    {
                        Name = componentName,
                        Properties = GetProperties(componentElement.Value, e, loadedVersion.NSR, enumTypesByValueSetUrl)
                    };
                    resource.Components.Add(component);
                }
            }
        }
        return result;
    }

    public static Dictionary<string, Dictionary<string, ResourceDetails>> LoadAll(
        IEnumerable<LoadedVersion> loadedVersions, 
        Dictionary<string, Dictionary<string, ValueSet>> valueSetsByEnumNameByVersion
    )
    {
        var enumTypesByValueSetUrlByVersion = loadedVersions.ToDictionary(
                loadedVersion => loadedVersion.Version,
                loadedVersion => valueSetsByEnumNameByVersion[string.Empty]
                    .Select(pair => new KeyValuePair<string, string>(pair.Value.Url, "Hl7.Fhir.Model." + pair.Key))
                    .Concat(valueSetsByEnumNameByVersion[loadedVersion.Version].Select(pair => new KeyValuePair<string, string>(pair.Value.Url, "Hl7.Fhir.Model." + loadedVersion.Version + "." + pair.Key)))
                    .ToDictionary(pair => pair.Key, pair => pair.Value)
            );

        var resourcesByNameByVersion = new Dictionary<string, Dictionary<string, ResourceDetails>>();
        foreach (var loadedVersion in loadedVersions)
        {
            var enumTypesByValueSetUrl = enumTypesByValueSetUrlByVersion[loadedVersion.Version];
            var resourcesByName = LoadTypes(loadedVersion, enumTypesByValueSetUrl);
            var resources = Load(loadedVersion, enumTypesByValueSetUrl);
            foreach (var resource in resources)
            {
                resourcesByName.Add(resource.Name, resource);
            }
            resourcesByNameByVersion.Add(loadedVersion.Version, resourcesByName);
        }
        ExtractShared(resourcesByNameByVersion);
        return resourcesByNameByVersion;
    }

    private static Dictionary<string, ResourceDetails> LoadTypes(LoadedVersion loadedVersion, Dictionary<string, string> enumTypesByValueSetUrl)
    {
        var result = new Dictionary<string, ResourceDetails>();
        var sdNodes = loadedVersion.Types.DocumentElement.SelectNodes(
            "/fhir:Bundle/fhir:entry/fhir:resource/fhir:StructureDefinition[fhir:base/@value = 'http://hl7.org/fhir/StructureDefinition/Element' or fhir:baseDefinition/@value = 'http://hl7.org/fhir/StructureDefinition/Element' or fhir:id/@value = 'Coding' or fhir:id/@value = 'code' or fhir:id/@value = 'oid' or fhir:id/@value = 'id' or fhir:id/@value = 'uuid' or fhir:id/@value = 'Annotation' or fhir:id/@value = 'Attachment' or fhir:id/@value = 'unsignedInt' or fhir:id/@value = 'positiveInt' or fhir:id/@value = 'markdown']", 
            loadedVersion.NST
        );
        foreach (var e in sdNodes.OfType<XmlElement>())
        {
            var resourceName = e.SelectSingleNode("fhir:name/@value", loadedVersion.NST).Value;
            var rawResourceName = resourceName;

            string primitiveTypeName = null;
            if (resourceName == "string")
            {
                resourceName = "FhirString";
                primitiveTypeName = "string";
            }
            else if (resourceName == "decimal")
            {
                resourceName = "FhirDecimal";
                primitiveTypeName = "decimal?";
            }
            else if (resourceName == "uri")
            {
                resourceName = "FhirUri";
                primitiveTypeName = "string";
            }
            else if (resourceName == "narrative")
            {
                resourceName = "Narrative";
                primitiveTypeName = "string";
            }
            else if (resourceName == "boolean")
            {
                resourceName = "FhirBoolean";
                primitiveTypeName = "bool?";
            }
            else if (resourceName == "dateTime")
            {
                resourceName = "FhirDateTime";
                primitiveTypeName = "string";
            }
            else if (resourceName == "date")
            {
                resourceName = "Date";
                primitiveTypeName = "string";
            }
            else if (resourceName == "time")
            {
                resourceName = "Time";
                primitiveTypeName = "string";
            }
            else if (resourceName == "instant")
            {
                resourceName = "Instant";
                primitiveTypeName = "DateTimeOffset?";
            }
            else if (resourceName == "integer")
            {
                resourceName = "Integer";
                primitiveTypeName = "int?";
            }
            else if (resourceName == "positiveInt")
            {
                resourceName = "PositiveInt";
                primitiveTypeName = "int?";
            }
            else if (resourceName == "unsignedInt")
            {
                resourceName = "UnsignedInt";
                primitiveTypeName = "int?";
            }
            else if (resourceName == "code")
            {
                resourceName = "Code";
                primitiveTypeName = "string";
            }
            else if (resourceName == "base64Binary")
            {
                resourceName = "Base64Binary";
                primitiveTypeName = "byte[]";
            }
            else if (resourceName == "Reference")
            {
                resourceName = "ResourceReference";
            }
            else
            {
                resourceName = resourceName.Substring(0, 1).ToUpper() + resourceName.Substring(1);
                primitiveTypeName = "string";
            }

            var resourceBaseType = "Hl7.Fhir.Model.DomainResource";
            var definedBaseTypeNode = GetBaseTypeNode(e, loadedVersion.NST);
            if (definedBaseTypeNode != null)
            {
                var definedBaseType = definedBaseTypeNode.Value;
                resourceBaseType = definedBaseType;
                if (resourceBaseType == "http://hl7.org/fhir/StructureDefinition/Element")
                {
                    if (rawResourceName.Substring(0, 1).ToLower() == rawResourceName.Substring(0, 1))
                    {
                        resourceBaseType = "Hl7.Fhir.Model.Primitive<" + primitiveTypeName + ">";
                    }
                    else
                        resourceBaseType = "Hl7.Fhir.Model.Element";
                }
                else
                    resourceBaseType = "Hl7.Fhir.Model.Primitive<" + primitiveTypeName + ">";
            }

            var toSkip = new[] { "Resource", "DomainResource", "Xhtml", "Narrative", "Extension" };
            if (!toSkip.Contains(resourceName) && resourceBaseType != "Hl7.Fhir.Model.Quantity")
            {
                var resource = new ResourceDetails { Name = resourceName, RawName = rawResourceName, PrimitiveTypeName = primitiveTypeName, BaseType = resourceBaseType };
                result.Add(resource.Name, resource);

                var resourceDescriptionNode = e.SelectSingleNode("fhir:differential/fhir:element[fhir:path/@value='" + rawResourceName + "']/fhir:short/@value", loadedVersion.NST);
                resource.Description = resourceDescriptionNode != null ?
                    resourceDescriptionNode.Value :
                    string.Empty;


                resource.IsPrimitive = resourceBaseType.Contains("Primitive<");
                resource.AbstractType = (e.SelectSingleNode("fhir:abstract[@value='true']", loadedVersion.NST) != null);

                var patternNode = e.SelectSingleNode("fhir:differential/fhir:element/fhir:type/fhir:extension[@url='http://hl7.org/fhir/StructureDefinition/structuredefinition-regex']/fhir:valueString/@value", loadedVersion.NST);
                resource.Pattern = patternNode != null ? patternNode.Value : null;

                // Make the DSTU2 and STU3 Code patterns the same (the STU3 one seems just plain wrong)
                if (resource.Pattern == @"[^\s]+([\s]?[^\s]+)*")
                {
                    resource.Pattern = @"[^\s]+([\s][^\s]+)*";
                }

                resource.Properties = resource.IsPrimitive ?
                    new List<PropertyDetails>() :
                    GetProperties(rawResourceName, e, loadedVersion.NST, enumTypesByValueSetUrl);

                resource.Components = new List<ComponentDetails>();
                foreach (var e2 in e.SelectNodes("fhir:differential/fhir:element[fhir:type/fhir:code/@value = 'Element']", loadedVersion.NST).OfType<XmlElement>())
                {
                    var componentElement = e2.SelectSingleNode("fhir:path/@value", loadedVersion.NST) as XmlAttribute;
                    var v = componentElement.Value;
                    if (v.Contains("."))
                    {
                        var index = v.LastIndexOf(".");
                        v = v.Substring(index + 1, 1).ToUpper() + v.Substring(index + 2);
                        string componentName = v + "Component";
                        var componentNameElement = (XmlAttribute)e2.SelectSingleNode("fhir:extension[@url = 'http://hl7.org/fhir/StructureDefinition/structuredefinition-explicit-type-name']/fhir:valueString/@value", loadedVersion.NST);
                        if (componentNameElement != null)
                        {
                            componentName = componentNameElement.Value + "Component";
                        }

                        var component = new ComponentDetails
                        {
                            Name = componentName,
                            Properties = GetProperties(componentElement.Value, e, loadedVersion.NST, enumTypesByValueSetUrl)
                        };
                        resource.Components.Add(component);
                    }
                }
            }
        }
        return result;
    }

    private static XmlNode GetBaseTypeNode(XmlElement structureDefinitionElement, XmlNamespaceManager ns)
    {
        var result = structureDefinitionElement.SelectSingleNode("fhir:base/@value", ns); // DSTU2
        if (result == null)
        {
            result = structureDefinitionElement.SelectSingleNode("fhir:baseDefinition/@value", ns); // STU3
        }
        return result;
    }

    private static List<PropertyDetails> GetProperties(string resourceName, XmlElement e, XmlNamespaceManager ns, Dictionary<string, string> enumTypesByValueSetUrl)
    {
        var result = new List<PropertyDetails>();
        foreach (var snapshotElement in e.SelectNodes("fhir:differential/fhir:element", ns).OfType<XmlElement>())
        {
            var pd = PropertyDetails.Parse(resourceName, snapshotElement, ns, enumTypesByValueSetUrl);
            if (pd != null)
            {
                result.Add(pd);
            }
        }
        return result;
    }

    private static void ExtractShared(Dictionary<string, Dictionary<string, ResourceDetails>> resourcesByNameByVersion)
    {
        var sharedResourcesByName = new Dictionary<string, ResourceDetails>();
        var allNamesInDependencyOrder = resourcesByNameByVersion.Values
            .SelectMany(resourcesByName => TopologicalSort(resourcesByName))
            .Select(resource => resource.Name)
            .Distinct()
            .ToList();
        foreach (var name in allNamesInDependencyOrder)
        {
            var versionAndResourcesWithSameName = resourcesByNameByVersion
                .Where(pair => pair.Value.ContainsKey(name))
                .Select(pair => new KeyValuePair<string, ResourceDetails>(pair.Key, pair.Value[name]))
                .ToList();
            var firstVersion = versionAndResourcesWithSameName[0].Key;
            var firstResourceWithSameName = versionAndResourcesWithSameName[0].Value;
            if (versionAndResourcesWithSameName.Count > 1 && 
                versionAndResourcesWithSameName.Skip(1).All(pair => firstResourceWithSameName.IsSame(pair.Value)) && 
                firstResourceWithSameName.GetReferencedFhirTypes().All(type => !resourcesByNameByVersion[firstVersion].ContainsKey(type)))
            {
                sharedResourcesByName.Add(name, ResourceDetails.MergeSame(versionAndResourcesWithSameName));
                foreach (var resourcesByName in resourcesByNameByVersion.Values)
                {
                    resourcesByName.Remove(name);
                }
            }
        }
        FixFhirTypes(resourcesByNameByVersion);
        resourcesByNameByVersion.Add(string.Empty, sharedResourcesByName);
    }

    private static void FixFhirTypes(Dictionary<string, Dictionary<string, ResourceDetails>> resourcesByNameByVersion)
    {
        foreach (var pair in resourcesByNameByVersion)
        {
            foreach (var resource in pair.Value.Values)
            {
                resource.FixReferencedFhirTypes(pair.Key, pair.Value);
            }
        }
    }

    private static List<ResourceDetails> TopologicalSort(Dictionary<string, ResourceDetails> resourcesByName)
    {
        var result = new List<ResourceDetails>();
        var visited = new HashSet<string>();
        foreach (var resource in resourcesByName.Values)
        {
            if (!visited.Contains(resource.Name))
            {
                TopologicalSort(resourcesByName, resource, visited, result);
            }
        }
        return result;
    }

    private static void TopologicalSort(Dictionary<string, ResourceDetails> resourcesByName, ResourceDetails current, HashSet<string> visited, List<ResourceDetails> result)
    {
        visited.Add(current.Name);
        foreach (var referencedFhirType in current.GetReferencedFhirTypes())
        {
            ResourceDetails referencedResource;
            if (resourcesByName.TryGetValue(referencedFhirType, out referencedResource) && !visited.Contains(referencedResource.Name))
            {
                TopologicalSort(resourcesByName, referencedResource, visited, result);
            }
        }
        result.Add(current);
    }
}

public class ComponentDetails
{
    public string Name;
    public List<PropertyDetails> Properties;

    public bool IsSame(ComponentDetails other)
    {
        return other != null &&
            Name == other.Name &&
            Properties.Count == other.Properties.Count &&
            Properties.OrderBy(p => p.Name).Zip(other.Properties.OrderBy(p => p.Name), (p1, p2) => p1.IsSame(p2)).All(same => same);
    }

    public static ComponentDetails MergeSame(IEnumerable<KeyValuePair<string, ComponentDetails>> versionAndComponents)
    {
        var firstComponent = versionAndComponents.First().Value;
        return new ComponentDetails
        {
            Name = firstComponent.Name,
            Properties = firstComponent.Properties
                .Select(
                    prop => PropertyDetails.MergeSame(
                        versionAndComponents.Select(pair => new KeyValuePair<string, PropertyDetails>(pair.Key, pair.Value.Properties.Single(p => p.Name == prop.Name)))
                    )
                )
                .ToList(),
        };
    }
}

public class PropertyDetails
{
    public string Name;
    public string FhirName;
    public string PropType;
    public HashSet<string> IsSummaryVersions = new HashSet<string>();
    public string Summary = string.Empty;
    public string CardMin;
    public string CardMax;
    public List<string> ReferenceTargets = new List<string>();
    public string NativeType;
    public string NativeName;
    public List<string> AllowedTypes = new List<string>();
    public string BackboneComponentType;
    public string CodeRequiredBinding;
    public bool isXmlAttribute;

    public bool IsSame(PropertyDetails other)
    {
        return other != null &&
            PropType == other.PropType &&
            Name == other.Name &&
            CardMin == other.CardMin &&
            CardMax == other.CardMax &&
            ReferenceTargets.Count == other.ReferenceTargets.Count &&
            ReferenceTargets.OrderBy(t => t).Zip(other.ReferenceTargets.OrderBy(t => t), (t1, t2) => t1 == t2).All(same => same) &&
            AllowedTypes.Count == other.AllowedTypes.Count &&
            AllowedTypes.OrderBy( t => t ).Zip( other.AllowedTypes.OrderBy( t => t), (t1, t2) => t1 == t2 ).All( same => same ) &&
            BackboneComponentType == other.BackboneComponentType;
    }

    public static PropertyDetails MergeSame(IEnumerable<KeyValuePair<string, PropertyDetails>> versionAndProperties)
    {
        var firstProperty = versionAndProperties.First().Value;
        var isSummaryVersions = versionAndProperties
            .Where(pair => pair.Value.IsSummaryVersions.Count > 0)
            .Select(pair => pair.Key).ToList();
        return new PropertyDetails
        {
            Name = firstProperty.Name,
            FhirName = firstProperty.FhirName,
            PropType = firstProperty.PropType,
            IsSummaryVersions = isSummaryVersions.Count == 0 ?
                new HashSet<string>() :
                isSummaryVersions.Count == versionAndProperties.Count() ?
                    new HashSet<string>(new[] { string.Empty }) : // All versions
                    new HashSet<string>(isSummaryVersions),
            Summary = firstProperty.Summary,
            CardMin = firstProperty.CardMin,
            CardMax = firstProperty.CardMax,
            ReferenceTargets = new List<string>(firstProperty.ReferenceTargets),
            NativeType = firstProperty.NativeType,
            NativeName = firstProperty.NativeName,
            AllowedTypes = new List<string>( firstProperty.AllowedTypes ),
            BackboneComponentType = firstProperty.BackboneComponentType,
            CodeRequiredBinding = firstProperty.CodeRequiredBinding,
            isXmlAttribute = firstProperty.isXmlAttribute
        };
    }

    public string PropTypeWithCard()
    {
        if (CardMax == "*")
            return "List<" + PropType + ">";
        return PropType;
    }

    public bool IsMultiCard()
    {
        if (CardMax == "*")
            return true;
        return false;
    }

    public IEnumerable<string> GetReferencedFhirTypes()
    {
        const string prefix = "Hl7.Fhir.Model.";
        if (PropType.StartsWith(prefix))
        {
            yield return PropType.Substring(prefix.Length);
        }
        foreach (var allowedType in AllowedTypes)
        {
            if (allowedType.StartsWith(prefix))
            {
                yield return allowedType.Substring(prefix.Length);
            }
        }
        foreach (var referenceTarget in ReferenceTargets)
        {
            if (referenceTarget.StartsWith(prefix))
            {
                yield return referenceTarget.Substring(prefix.Length);
            }
        }
    }

    public void FixReferencedFhirTypes(string version, Dictionary<string, ResourceDetails> resourcesByName)
    {
        PropType = FixReferencedFhirType(PropType, version, resourcesByName);
        AllowedTypes = AllowedTypes
            .Select(allowedType => FixReferencedFhirType(allowedType, version, resourcesByName))
            .ToList();
        ReferenceTargets = ReferenceTargets
            .Select(referenceTarget => FixReferencedFhirType(referenceTarget, version, resourcesByName))
            .ToList();
    }

    private static string FixReferencedFhirType(string type, string version, Dictionary<string, ResourceDetails> resourcesByName)
    {
        const string prefix = "Hl7.Fhir.Model.";
        if (type.StartsWith(prefix) && resourcesByName.ContainsKey(type.Substring(prefix.Length)))
        {
            return prefix + version + "." + type.Substring(prefix.Length);
        }
        return type;
    }

    public static string ConvertPropertyType(string propType, XmlElement element, XmlNamespaceManager ns)
    {
        switch (propType)
        {
            case "id": return "Hl7.Fhir.Model.Id";
            case "Reference": return "Hl7.Fhir.Model.ResourceReference";
            case "code": return "Hl7.Fhir.Model.Code";
            case "oid": return "Hl7.Fhir.Model.Oid";
            case "uri": return "Hl7.Fhir.Model.FhirUri";
            case "boolean": return "Hl7.Fhir.Model.FhirBoolean";
            case "dateTime": return "Hl7.Fhir.Model.FhirDateTime";
            case "date": return "Hl7.Fhir.Model.Date";
            case "time": return "Hl7.Fhir.Model.Time";
            case "base64Binary": return "Hl7.Fhir.Model.Base64Binary";
            case "decimal": return "Hl7.Fhir.Model.FhirDecimal";
            case "markdown": return "Hl7.Fhir.Model.Markdown";
            case "xhtml": return "Hl7.Fhir.Model.Xhtml";
            case "instant": return "Hl7.Fhir.Model.Instant";
            case "integer": return "Hl7.Fhir.Model.Integer";
            case "unsignedInt": return "Hl7.Fhir.Model.UnsignedInt";
            case "positiveInt": return "Hl7.Fhir.Model.PositiveInt";
            case "string": return "Hl7.Fhir.Model.FhirString";
            case "Quantity":
                return GetQuantityType(element, ns);
        }
        return "Hl7.Fhir.Model." + propType;
    }

    public static PropertyDetails Parse(string resourceName, XmlElement element, XmlNamespaceManager ns, Dictionary<string, string> enumTypesByValueSetUrl)
    {
        PropertyDetails result = new PropertyDetails();
        if (element.SelectSingleNode("fhir:isSummary[@value = 'true']", ns) != null)
            result.IsSummaryVersions.Add(string.Empty);
        if (element.SelectSingleNode("fhir:representation[@value = 'xmlAttr']", ns) != null)
            result.isXmlAttribute = true;
        if (element.SelectSingleNode("fhir:short/@value", ns) != null)
            result.Summary = element.SelectSingleNode("fhir:short/@value", ns).Value;
        if (element.SelectSingleNode("fhir:type/fhir:code/@value", ns) != null)
            result.PropType = element.SelectSingleNode("fhir:type/fhir:code/@value", ns).Value;
        else
            result.PropType = "BackboneElement";

        // Check for a nameReference to another property
        XmlAttribute attrNameRef = element.SelectSingleNode("fhir:nameReference/@value", ns) as XmlAttribute;
        if (attrNameRef != null)
        {
            var nameRef = attrNameRef.Value;
            var elemNameRef = (element.ParentNode as XmlElement).SelectSingleNode("fhir:element[fhir:name/@value = '" + nameRef + "']", ns) as XmlElement;
            var temp = ParseType(elemNameRef, ns, enumTypesByValueSetUrl);
            if (temp != null)
            {
                result.PropType = temp.PropType;
                result.BackboneComponentType = temp.BackboneComponentType;
                result.NativeType = temp.NativeType;
                result.ReferenceTargets = temp.ReferenceTargets;
                result.AllowedTypes = temp.AllowedTypes;
            }
        }

        result.FhirName = element.SelectSingleNode("fhir:path/@value", ns).Value;
        if (!result.FhirName.StartsWith(resourceName + "."))
            return null;
        if (result.PropType == "BackboneElement" || result.PropType == "Element")
        {
            var componentName = (XmlAttribute)element.SelectSingleNode("fhir:extension[@url = 'http://hl7.org/fhir/StructureDefinition/structuredefinition-explicit-type-name']/fhir:valueString/@value", ns);
            if (componentName != null)
            {
                result.BackboneComponentType = "Hl7.Fhir.Model." + resourceName + "." + componentName.Value + "Component";
            }
            else
            {
                var v = result.FhirName;
                var index = v.LastIndexOf(".");
                v = v.Substring(index + 1, 1).ToUpper() + v.Substring(index + 2);
                result.BackboneComponentType = "Hl7.Fhir.Model." + resourceName + "." + v + "Component";
            }
        }
        result.FhirName = result.FhirName.Substring(resourceName.Length + 1);

        // Strip out any child component props
        if (result.FhirName.Contains("."))
            return null;

        result.Name = result.FhirName.ToUpper().Substring(0, 1) + result.FhirName.Substring(1); // convert this to the actual property name

        // A property name cannot be the same as the classname, otherwise c# thinks this is a constructor!
        if (result.Name == resourceName)
            result.Name += "_";

        result.CardMin = element.SelectSingleNode("fhir:min/@value", ns).Value;
        result.CardMax = element.SelectSingleNode("fhir:max/@value", ns).Value;

        string[] NativeTypes = { "decimal", "dateTime", "time", "integer", "oid", "date", "id", "Code", "code", "instant", "unsignedInt", "positiveInt", "string", "boolean", "uri", "base64Binary" };
        if (NativeTypes.Contains(result.PropType))
        {
            result.NativeName = result.Name;
            result.Name = result.Name + "Element";
            result.NativeType = result.PropType;
        }

        switch (result.PropType)
        {
            case "id":
                result.PropType = "Hl7.Fhir.Model.Id";
                result.NativeType = "string";
                break;
            case "Reference":
                result.PropType = "Hl7.Fhir.Model.ResourceReference";
                break;
            case "Code":
                result.PropType = "Hl7.Fhir.Model.Code";
                result.NativeType = "string";
                // If the binding is required, then we can change to the 
                // locally defined enumeration type
                break;
            case "code":
                result.PropType = "Hl7.Fhir.Model.Code";
                result.NativeType = "string";
                // If the binding is required, then we can change to the 
                // locally defined enumeration type
                break;
            case "oid":
                result.PropType = "Hl7.Fhir.Model.Oid";
                result.NativeType = "string";
                break;
            case "integer":
                result.PropType = "Hl7.Fhir.Model.Integer";
                result.NativeType = "int?";
                break;
            case "boolean":
                result.PropType = "Hl7.Fhir.Model.FhirBoolean";
                result.NativeType = "bool?";
                break;
            case "uri":
                result.PropType = "Hl7.Fhir.Model.FhirUri";
                result.NativeType = "string";
                break;
            case "base64Binary":
                result.PropType = "Hl7.Fhir.Model.Base64Binary";
                result.NativeType = "byte[]";
                break;
            case "Resource":
                result.PropType = "Hl7.Fhir.Model.Resource";
                result.AllowedTypes = new List<string> { "Hl7.Fhir.Model.Resource" };
                break;
            case "dateTime":
                result.PropType = "Hl7.Fhir.Model.FhirDateTime";
                result.NativeType = "string";
                break;
            case "date":
                result.PropType = "Hl7.Fhir.Model.Date";
                result.NativeType = "string";
                break;
            case "time":
                result.PropType = "Hl7.Fhir.Model.Time";
                result.NativeType = "string";
                break;
            case "instant":
                result.PropType = "Hl7.Fhir.Model.Instant";
                result.NativeType = "DateTimeOffset?";
                break;
            case "unsignedInt":
                result.PropType = "Hl7.Fhir.Model.UnsignedInt";
                result.NativeType = "int?";
                break;
            case "positiveInt":
                result.PropType = "Hl7.Fhir.Model.PositiveInt";
                result.NativeType = "int?";
                break;
            case "decimal":
                result.PropType = "Hl7.Fhir.Model.FhirDecimal";
                result.NativeType = "decimal?";
                break;
            case "string":
                result.PropType = "Hl7.Fhir.Model.FhirString";
                result.NativeType = "string";
                break;
            case "BackboneElement":
                result.PropType = result.BackboneComponentType;
                break;
            case "Quantity":
                result.PropType = GetQuantityType(element, ns);
                break;
            default:
                result.PropType = "Hl7.Fhir.Model." + result.PropType;
                break;
        }

        if (result.Name.Contains("[x]"))
        {
            result.PropType = "Hl7.Fhir.Model.Element";
            result.Name = result.Name.Substring(0, result.Name.IndexOf("["));
            result.FhirName = result.FhirName.Substring(0, result.FhirName.IndexOf("["));
            result.AllowedTypes = new List<string>();

            foreach (var erp in element.SelectNodes("fhir:type/fhir:code/@value", ns).OfType<XmlAttribute>())
            {
                string allowType = ConvertPropertyType(erp.Value.Substring(erp.Value.LastIndexOf("/") + 1), element, ns);
                if (!result.AllowedTypes.Contains(allowType))
                {
                    result.AllowedTypes.Add(allowType);
                }
            }
        }

        if (result.PropType == "Hl7.Fhir.Model.ResourceReference")
        {
            result.ReferenceTargets = GetPossibleReferenceTargets(element, ns);
        }

        if (result.PropType == "Code" || result.PropType == "Hl7.Fhir.Model.Code")
        {
            // Grab the binding from the element
            if (element.SelectSingleNode("fhir:binding[fhir:strength/@value = 'required']/fhir:valueSetReference/fhir:reference/@value", ns) != null)
                result.CodeRequiredBinding = element.SelectSingleNode("fhir:binding[fhir:strength/@value = 'required']/fhir:valueSetReference/fhir:reference/@value", ns).Value;
            if (!string.IsNullOrEmpty(result.CodeRequiredBinding) && result.CodeRequiredBinding != "http://hl7.org/fhir/ValueSet/operation-parameter-type")
            {
                if (!enumTypesByValueSetUrl.ContainsKey(result.CodeRequiredBinding))
                {
                    result.CodeRequiredBinding = element.SelectSingleNode("fhir:path/@value", ns).Value;
                    if (result.CodeRequiredBinding.Contains(resourceName + "."))
                        result.CodeRequiredBinding = result.CodeRequiredBinding.Substring(resourceName.Length + 1, 1).ToUpper() + result.CodeRequiredBinding.Substring(resourceName.Length + 2);
                    while (result.CodeRequiredBinding.Contains("."))
                    {
                        int index = result.CodeRequiredBinding.IndexOf(".");
                        result.CodeRequiredBinding = result.CodeRequiredBinding.Substring(0, index) + result.CodeRequiredBinding.Substring(index + 1, 1).ToUpper() + result.CodeRequiredBinding.Substring(index + 2);
                    }
                }
                else
                {
                    result.CodeRequiredBinding = enumTypesByValueSetUrl[result.CodeRequiredBinding];
                }
                // result.CodeRequiredBinding = result.CodeRequiredBinding.Substring(resourceName.Length);
                result.PropType = result.PropType + "<" + result.CodeRequiredBinding + ">";
                result.NativeType = result.CodeRequiredBinding + "?";
            }
        }

        if (result.NativeName != null && result.NativeName.Contains("[x]"))
        {
            result.NativeName = null;
            result.NativeType = null;
        }

        return result;
    }

    public static PropertyDetails ParseType(XmlElement element, XmlNamespaceManager ns, Dictionary<string, string> enumTypesByValueSetUrl)
    {
        PropertyDetails result = new PropertyDetails();
        string ResourceBase = element.SelectSingleNode("fhir:path/@value", ns).Value;
        if (ResourceBase.Contains("."))
            ResourceBase = ResourceBase.Substring(0, ResourceBase.IndexOf("."));
        if (element.SelectSingleNode("fhir:type/fhir:code/@value", ns) != null)
            result.PropType = element.SelectSingleNode("fhir:type/fhir:code/@value", ns).Value;
        else
            result.PropType = "BackboneElement";
        result.FhirName = element.SelectSingleNode("fhir:path/@value", ns).Value;
        //	if (result.FhirName.StartsWith(ResourceBase + "."))
        //		result.FhirName = result.FhirName.Substring(result.FhirName.IndexOf(".") + 1);
        result.FhirName = result.FhirName.ToUpper().Substring(0, 1) + result.FhirName.Substring(1); // convert this to the actual property name

        if (result.PropType == "BackboneElement" || result.PropType == "Element")
        {
            string v = result.FhirName;
            if (v.Contains("."))
            {
                int index = v.LastIndexOf(".");
                v = v.Substring(index + 1, 1).ToUpper() + v.Substring(index + 2);
            }
            result.BackboneComponentType = "Hl7.Fhir.Model." + ResourceBase + "." + v + "Component";
            var componentName = (XmlAttribute)element.SelectSingleNode("fhir:extension[@url = 'http://hl7.org/fhir/StructureDefinition/structuredefinition-explicit-type-name']/fhir:valueString/@value", ns);
            if (componentName != null)
            {
                result.BackboneComponentType = "Hl7.Fhir.Model." + ResourceBase + "." + componentName.Value + "Component";
            }
        }

        // Check for a nameReference to another property
        XmlAttribute attrNameRef = element.SelectSingleNode("fhir:nameReference/@value", ns) as XmlAttribute;
        if (attrNameRef != null)
        {
            string nameRef = attrNameRef.Value;
            XmlElement elemNameRef = (element.ParentNode as XmlElement).SelectSingleNode("fhir:element[fhir:name/@value = '" + nameRef + "']", ns) as XmlElement;
            PropertyDetails temp = ParseType(elemNameRef, ns, enumTypesByValueSetUrl);
            if (temp != null)
            {
                result.PropType = temp.PropType;
                result.BackboneComponentType = temp.BackboneComponentType;
                result.NativeType = temp.NativeType;
            }
        }

        if (result.PropType == "BackboneElement" || result.PropType == "Element")
        {
            string v = result.FhirName;
            if (v.Contains("."))
            {
                int index = v.LastIndexOf(".");
                v = v.Substring(index + 1, 1).ToUpper() + v.Substring(index + 2);
            }
            result.BackboneComponentType = "Hl7.Fhir.Model." + ResourceBase + "." + v + "Component";
            var componentName = (XmlAttribute)element.SelectSingleNode("fhir:extension[@url = 'http://hl7.org/fhir/StructureDefinition/structuredefinition-explicit-type-name']/fhir:valueString/@value", ns);
            if (componentName != null)
            {
                result.BackboneComponentType = "Hl7.Fhir.Model." + ResourceBase + "." + componentName.Value + "Component";
            }
        }
        string[] NativeTypes = { "decimal", "dateTime", "integer", "oid", "date", "id", "Code", "code", "instant", "unsignedInt", "positiveInt", "string", "boolean", "uri", "base64Binary" };
        if (NativeTypes.Contains(result.PropType))
        {
            result.NativeType = result.PropType;
        }

        switch (result.PropType)
        {
            case "id":
                result.PropType = "Hl7.Fhir.Model.Id";
                result.NativeType = "string";
                break;
            case "Reference":
                result.PropType = "Hl7.Fhir.Model.ResourceReference";
                break;
            case "Resource":
                result.PropType = "Hl7.Fhir.Model.Resource";
                result.AllowedTypes = new List<string> { "Hl7.Fhir.Model.Resource" };
                break;
            case "Code":
                result.PropType = "Hl7.Fhir.Model.Code";
                result.NativeType = "string";
                // If the binding is required, then we can change to the 
                // locally defined enumeration type
                break;
            case "code":
                result.PropType = "Hl7.Fhir.Model.Code";
                result.NativeType = "string";
                // If the binding is required, then we can change to the 
                // locally defined enumeration type
                break;
            case "markdown":
                result.PropType = "Hl7.Fhir.Model.Markdown";
                break;
            case "oid":
                result.PropType = "Hl7.Fhir.Model.Oid";
                result.NativeType = "string";
                break;
            case "integer":
                result.PropType = "Hl7.Fhir.Model.Integer";
                result.NativeType = "int?";
                break;
            case "boolean":
                result.PropType = "Hl7.Fhir.Model.FhirBoolean";
                result.NativeType = "bool?";
                break;
            case "uri":
                result.PropType = "Hl7.Fhir.Model.FhirUri";
                result.NativeType = "string";
                break;
            case "base64Binary":
                result.PropType = "Hl7.Fhir.Model.Base64Binary";
                result.NativeType = "byte[]";
                break;
            case "dateTime":
                result.PropType = "Hl7.Fhir.Model.FhirDateTime";
                result.NativeType = "string";
                break;
            case "date":
                result.PropType = "Hl7.Fhir.Model.Date";
                result.NativeType = "string";
                break;
            case "time":
                result.PropType = "Hl7.Fhir.Model.Time";
                break;
            case "instant":
                result.PropType = "Hl7.Fhir.Model.Instant";
                result.NativeType = "DateTimeOffset?";
                break;
            case "unsignedInt":
                result.PropType = "Hl7.Fhir.Model.UnsignedInt";
                result.NativeType = "int?";
                break;
            case "positiveInt":
                result.PropType = "Hl7.Fhir.Model.PositiveInt";
                result.NativeType = "int?";
                break;
            case "decimal":
                result.PropType = "Hl7.Fhir.Model.FhirDecimal";
                result.NativeType = "decimal?";
                break;
            case "string":
                result.PropType = "Hl7.Fhir.Model.FhirString";
                result.NativeType = "string";
                break;
            case "BackboneElement":
                result.PropType = result.BackboneComponentType;
                break;
            case "Quantity":
                result.PropType = GetQuantityType(element, ns);
                break;
            default:
                result.PropType = "Hl7.Fhir.Model." + result.PropType;
                break;
        }

        if (result.PropType == "Hl7.Fhir.Model.ResourceReference")
        {
            result.ReferenceTargets = GetPossibleReferenceTargets(element, ns);
        }

        if (result.PropType == "Code" || result.PropType == "Hl7.Fhir.Model.Code")
        {
            // Grab the binding from the element
            if (element.SelectSingleNode("fhir:binding[fhir:strength/@value = 'required']/fhir:valueSetReference/fhir:reference/@value", ns) != null)
                result.CodeRequiredBinding = element.SelectSingleNode("fhir:binding[fhir:strength/@value = 'required']/fhir:valueSetReference/fhir:reference/@value", ns).Value;
            if (!string.IsNullOrEmpty(result.CodeRequiredBinding) && result.CodeRequiredBinding != "http://hl7.org/fhir/ValueSet/operation-parameter-type")
            {
                if (!enumTypesByValueSetUrl.ContainsKey(result.CodeRequiredBinding))
                {
                    result.CodeRequiredBinding = element.SelectSingleNode("fhir:path/@value", ns).Value;
                    if (result.CodeRequiredBinding.Contains(ResourceBase + "."))
                        result.CodeRequiredBinding = result.CodeRequiredBinding.Substring(ResourceBase.Length + 1, 1).ToUpper() + result.CodeRequiredBinding.Substring(ResourceBase.Length + 2);
                    while (result.CodeRequiredBinding.Contains("."))
                    {
                        int index = result.CodeRequiredBinding.IndexOf(".");
                        result.CodeRequiredBinding = result.CodeRequiredBinding.Substring(0, index) + result.CodeRequiredBinding.Substring(index + 1, 1).ToUpper() + result.CodeRequiredBinding.Substring(index + 2);
                    }
                }
                else
                {
                    result.CodeRequiredBinding = enumTypesByValueSetUrl[result.CodeRequiredBinding];
                }
                // result.CodeRequiredBinding = result.CodeRequiredBinding.Substring(ResourceBase.Length);
                result.PropType = result.PropType + "<" + result.CodeRequiredBinding + ">";
                result.NativeType = result.CodeRequiredBinding + "?";
            }
        }

        return result;
    }

    private static List<string> GetPossibleReferenceTargets(XmlElement element, XmlNamespaceManager ns)
    {
        var result = new List<string>();
        foreach (var erp in element.SelectNodes("fhir:type[fhir:code/@value = 'Reference']/fhir:profile/@value|fhir:type[fhir:code/@value = 'Reference']/fhir:targetProfile/@value", ns).OfType<XmlAttribute>())
        {
            var typeName = erp.Value.Substring(erp.Value.LastIndexOf("/") + 1);
            if (typeName != "Resource")
            {
                result.Add("Hl7.Fhir.Model." + typeName);
            }
        }
        return result;
    }

    private static string GetQuantityType(XmlElement element, XmlNamespaceManager ns)
    {
        var typeProfile = (XmlAttribute)element.SelectSingleNode("fhir:type/fhir:profile/@value", ns);
        if (typeProfile == null)
        {
            return "Hl7.Fhir.Model.Quantity";
        }
        if (typeProfile.Value == "http://hl7.org/fhir/StructureDefinition/SimpleQuantity")
        {
            return "Hl7.Fhir.Model.SimpleQuantity";
        }
        if (typeProfile.Value == "http://hl7.org/fhir/StructureDefinition/Money")
        {
            return "Hl7.Fhir.Model.Money";
        }
        if (typeProfile.Value == "http://hl7.org/fhir/StructureDefinition/Age")
        {
            return "Hl7.Fhir.Model.Age";
        }
        if (typeProfile.Value == "http://hl7.org/fhir/StructureDefinition/Duration")
        {
            return "Hl7.Fhir.Model.Duration";
        }
        return "Hl7.Fhir.Model.Quantity";
    }
}
#>